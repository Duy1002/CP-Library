<snippet>
	<content><![CDATA[
template<typename T = void>
struct graph {
    vector<tuple<int, int, T>> edges;
    vector<vector<int>> adj;
    graph(int n = 0): adj(n) {}
    int V() const {
        return adj.size();
    }
    int E() const {
        return edges.size();
    }
    void add_directed_edge(int u, int v, const T &w) {
        adj[u].emplace_back(edges.size());
        edges.emplace_back(u, v, w);
    }
    void add_undirected_edge(int u, int v, const T &w) {
        adj[u].emplace_back(edges.size());
        adj[v].emplace_back(edges.size());
        edges.emplace_back(u, v, w);
    }
    auto neighbors(int u) const {
        return adj[u] | views::transform([this, u] (int i) {
            return u ^ get<0>(edges[i]) ^ get<1>(edges[i]);
        });
    }
    auto neighbors_index(int u) const {
        return adj[u] | views::transform([this, u] (int i) {
            return make_pair(u ^ get<0>(edges[i]) ^ get<1>(edges[i]), i);
        });
    }
    auto neighbors_weight(int u) {
        return adj[u] | views::transform([this, u] (int i) -> pair<int, T&> {
            return {u ^ get<0>(edges[i]) ^ get<1>(edges[i]), get<2>(edges[i])};
        });
    }
    auto neighbors_weight(int u) const {
        return adj[u] | views::transform([this, u] (int i) -> pair<int, T&> {
            return {u ^ get<0>(edges[i]) ^ get<1>(edges[i]), get<2>(edges[i])};
        });
    }
    auto neighbors_weight_index(int u) {
        return adj[u] | views::transform([this, u] (int i) -> tuple<int, T&, int> {
            return {u ^ get<0>(edges[i]) ^ get<1>(edges[i]), get<2>(edges[i]), i};
        });
    }
    auto neighbors_weight_index(int u) const {
        return adj[u] | views::transform([this, u] (int i) -> tuple<int, const T&, int> {
            return {u ^ get<0>(edges[i]) ^ get<1>(edges[i]), get<2>(edges[i]), i};
        });
    }
};
template<>
struct graph<void> {
    vector<pair<int, int>> edges;
    vector<vector<int>> adj;
    graph(int n = 0): adj(n) {}
    int V() const {
        return adj.size();
    }
    int E() const {
        return edges.size();
    }
    void add_directed_edge(int u, int v) {
        adj[u].emplace_back(edges.size());
        edges.emplace_back(u, v);
    }
    void add_undirected_edge(int u, int v) {
        adj[u].emplace_back(edges.size());
        adj[v].emplace_back(edges.size());
        edges.emplace_back(u, v);
    }
    auto neighbors(int u) const {
        return adj[u] | views::transform([this, u] (int i) {
            return u ^ edges[i].first ^ edges[i].second;
        });
    }
    auto neighbors_index(int u) const {
        return adj[u] | views::transform([this, u] (int i) {
            return make_pair(u ^ edges[i].first ^ edges[i].second, i);
        });
    }
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>snippet_graph</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
</snippet>
