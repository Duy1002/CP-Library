<snippet>
	<content><![CDATA[
#include "bits/stdc++.h"
#ifdef LOCAL
#include <windows.h>
#include <psapi.h>
#endif
using namespace std;
unsigned __int128 read_uint128(string::iterator b, const string::iterator &e) {
    unsigned __int128 x = 0;
    for (; b != e; ++b) x = x * 10 + (*b - '0');
    return x;
}
istream& operator >> (istream &is, __int128 &x) {
    string s;
    is >> s;
    x = s[0] == '-' ? -read_uint128(s.begin() + 1, s.end()) : read_uint128(s.begin(), s.end());
    return is;
}
istream& operator >> (istream &is, unsigned __int128 &x) {
    string s;
    is >> s;
    x = read_uint128(s.begin(), s.end());
    return is;
}
template<typename T> istream& operator >> (istream &is, vector<T> &v);
template<typename F, typename S> istream& operator >> (istream &is, pair<F, S> &p);
template<typename... Ts> istream& operator >> (istream &is, tuple<Ts...> &t);
template<typename T>
istream& operator >> (istream &is, vector<T> &v) {
    for (auto &i: v) is >> i;
    return is;
}
template<typename F, typename S>
istream& operator >> (istream &is, pair<F, S> &p) {
    return is >> p.first >> p.second;
}
template<typename... Ts>
istream& operator >> (istream &is, tuple<Ts...> &t) {
    std::apply([&](auto&... elems) {((is >> elems), ...);}, t);
    return is;
}
ostream& print_uint128(ostream &os, const unsigned __int128 &x) {
    if (x >= 10) print_uint128(os, x / 10);
    return os << (char)(x % 10 + '0');
}
ostream& operator << (ostream &os, const __int128 &x) {
    if (x < 0) {
        os << '-';
        return print_uint128(os, -(unsigned __int128)x);
    }
    return print_uint128(os, x);
}
ostream& operator << (ostream &os, const unsigned __int128 &x) {
    return print_uint128(os, x);
}
template<typename T> ostream& operator << (ostream &os, const vector<T> &v);
template<typename F, typename S> ostream& operator << (ostream &os, const pair<F, S> &p);
template<typename... Ts> ostream& operator << (ostream &os, const tuple<Ts...> &t);
template<typename T>
ostream& print_vector(ostream &os, const vector<T> &v, const string &sep) {
    string s;
    for (const auto &i: v) os << s << i, s = sep;
    return os;
}
template<typename T>
ostream& operator << (ostream &os, const vector<T> &v) {
    return print_vector(os, v, " ");
}
template<typename F, typename S>
ostream& operator << (ostream &os, const vector<pair<F, S>> &v) {
    return print_vector(os, v, "\n");
}
template<typename... Ts>
ostream& operator << (ostream &os, const vector<tuple<Ts...>> &v) {
    return print_vector(os, v, "\n");
}
template<typename T>
ostream& operator << (ostream &os, const vector<vector<T>> &v) {
    return print_vector(os, v, "\n");
}
template<typename F, typename S>
ostream& operator << (ostream &os, const pair<F, S> &p) {
    return os << p.first << ' ' << p.second;
}
template<typename... Ts>
ostream& operator << (ostream &os, const tuple<Ts...> &t) {
    string s;
    std::apply([&](const auto&... elems) {((os << s << elems, s = " "), ...);}, t);
    return os;
}
template<typename T>
auto make_vector(const size_t &n) {
    return vector<T>(n);
}
template<typename T, typename... Args>
auto make_vector(const size_t &n, const Args&... args) {
    return vector<decltype(make_vector<T>(args...))>(n, make_vector<T>(args...));
}
template<typename T>
auto make_filled_vector(const size_t &n, const T &val) {
    return vector<T>(n, val);
}
template<typename T, typename... Args>
auto make_filled_vector(const size_t &n, const Args&... args) {
    return vector<decltype(make_filled_vector<T>(args...))>(n, make_filled_vector<T>(args...));
}
template<typename T, size_t N>
struct vec { using type = vector<typename vec<T, N - 1>::type>; };
template<typename T>
struct vec<T, 1> { using type = vector<T>; };
template<typename T, size_t N>
using vector_type = typename vec<T, N>::type;
void khac();
int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin.exceptions(ios::badbit | ios::failbit);
    #ifdef LOCAL
        PROCESS_MEMORY_COUNTERS pmc;
        GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));
        auto start_memory = pmc.PeakWorkingSetSize;
        auto start_time = chrono::high_resolution_clock::now();
    #endif
    khac();
    #ifdef LOCAL
        auto end_time = chrono::high_resolution_clock::now();
        GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));
        auto end_memory = pmc.PeakWorkingSetSize;
        auto used_time = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();
        auto used_memory = (end_memory - start_memory) / 1048576.0;
        cout << "\n=====\nUsed: " << used_time << " ms, ";
        cout << fixed << setprecision(3) << used_memory << " MB";
    #endif
}

void khac() {
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>template</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
</snippet>
